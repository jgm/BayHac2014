% Pandoc for Haskell Hackers
% John MacFarlane
% BayHac 2014

# Why am I here?

<div class="notes">
I'm a philosophy professor.  And this is just the sort of question
you expect a philosophy professor to ask---but I mean it in the
most mundane sense.  I have no formal background whatsoever
in computer science.  I think I'm a decent Haskell programmer, but nothing
close to an expert.  So why am I giving a talk at a Haskell hackathon?
</div>

# I created a virus...

---

# ...that spreads GHC

<div class="notes">
Because I created the most effective virus for spreading
GHC installations: pandoc.
</div>

| ![](images/virus1.png)
| ![](images/virus2.png)
| ![](images/virus3.png)
| ![](images/virus4.png)

----


           debian popcon            Hackage
-------- --------------- ------------------
pandoc              1997              26220
darcs               1908               3420
xmonad              1733               6432
-------- --------------- ------------------

![](images/downloads-google.png)

<!--

![Debian popcon graph](images/popcon-graph.png)

-->


# How did it happen?

![trs80](images/TRS80.jpg) ![kim1](images/KIM1.jpg)

<div class="notes">
I grew up programming video games in BASIC on a TRS-80 and 6502 assembly
on a KIM-1 that my grandfather bought (he must have been among the first
microcomputer hobbyists).  In college I worked summers as a programmer,
writing scientific software in Pascal on VAX workstations with whopping
20 MB hard drives.

I got out of programming when GUIs took over, but started to get
interested again in 2004 after installing linux.  I messed around with
python and lisp and ruby, and wrote a website for my department.  Then
in 2005, an Australian philosopher/logician colleague of mine, Greg
Restall, mentioned that his favorite programming language was Haskell.
So I checked it out, and found that I liked it too.

I started messing around with parsec, the parser combinator library.
I asked myself, "what would be fun to try to parse?"  I'd gotten
interested in lightweight markup languages and was using
reStructuredText for lecture notes and handouts.  And I'd just seen
this "markdown" thing that John Gruber introduced.  So I said to
myself, "Self, let's try writing a markdown parser."  That seemed
like a good challenge, because markdown is about as parser-unfriendly a
language as you can get.  An asterisk, for example, can be either an
open or close tag for emphasis, or *part of* an open or close tag for
strong emphasis, or just a literal asterisk---and which it is often
depends on what comes after.  At the time, the only markdown parsers
around were just big regex transformations.  Parsec worked well for
this.  Before long I had a working parser.  It was considerably faster
and more accurate than John Gruber's perl script.  And it was much
easier to maintain and extend.

One thing led to another.  I wasn't entirely happy with the docutils
(reStructuredText) tool chain, and I saw some advantages to "making my
own tools" for writing.  I needed to convert my existing documents in
reStructuredText to markdown, so I added a reStructuredText parser
and a markdown writer.  I needed output in LaTeX as well as HTML, so
I added a LaTeX writer.  I needed footnotes, inline LaTeX math, and
other features, so I extended pandoc's markdown dialect.  The project
provided hours of pleasant procrastination.
</div>

# First release

![](images/first-pandoc-web-page.png)

<div class="notes">
Then something possessed me to release it. In August 2006 I released the
first version.  Not long after that, a Debian developer, Recai Oktas,
contacted me offering to add it to debian.  So I became an open-source
developer, and I've worked on pandoc in my spare time ever since.
</div>

# Libraries begat libraries

> - highlighting-kate
> - zip-archive
> - texmath
> - pandoc-citeproc (citeproc-hs)
> - gitit

# The command-line tool

A quick demonstration.

<div class="notes">
Our goal is to learn how to use pandoc as a library,
but let's first have a quick demo of the command-line tool.

Run through `script.txt` in `demo/`.
</div>

# A tour of pandoc's API

# Readers and writers

[Text.Pandoc](doc/pandoc/Text-Pandoc.html)

<div class="notes">

Prelude> :m + Text.Pandoc
Text.Pandoc> let doc = readMarkdown def "*hi*"
Text.Pandoc> doc
Pandoc (Meta {unMeta = fromList []}) [Para [Emph [Str "hi"]]]
Text.Pandoc> writeLaTeX def doc
"\\emph{hi}"
Text.Pandoc> readMarkdown def{readerSmart = True} "dog's"
Pandoc (Meta {unMeta = fromList []}) [Para [Str "dog\8217s"]]

</div>

# The Pandoc types

[Text.Pandoc.Definition](doc/pandoc-types/Text-Pandoc-Definition.html)

. . .

You can use `pandoc -t native` and `pandoc -f native` to explore:

```
% echo "[*link*](/foo)" | pandoc -t native
[Para [Link [Emph [Str "link"]] ("/foo","")]]
```


# Builder

[Text.Pandoc.Builder](doc/pandoc-types/Text-Pandoc-Builder.html)


Concatenating lists is slow.  So we use special types `Inlines` and
`Blocks` that wrap `Sequence`s of `Inline` and `Block` elements.

# A simple example

Here's a JSON data source about CNG fueling stations in the Chicago
area:  [cng_fuel_chicago.json](cng_fuel_chicago.json.html).
Boss says:  write me a letter in Word listing all the stations
that take the Voyager card.

. . .

No need to open Word for this job! [fuel.hs](./fuel.hs.html)

# Transforming a Pandoc document

[Text.Pandoc.Generic](doc/pandoc-types/Text-Pandoc-Generic.html)

[Text.Pandoc.Walk](doc/pandoc-types/Text-Pandoc-Walk.html)

# Example: `walk`

```haskell
module AllCaps (allCaps) where
import Text.Pandoc.Definition
import Data.Char (toUpper)

allCaps :: Inline -> Inline
allCaps (Str xs) = Str $ map toUpper xs
allCaps x = x
```
. . .

```
% ghci AllCaps.hs
*AllCaps > Text.Pandoc.Walk.walk allCaps $ Para [Emph [Str "hi"]]
Para [Emph [Str "HI"]]
```

# Filters

Suppose we have a program that defines a transformation

```haskell
f :: Pandoc -> Pandoc
```

Since `Pandoc` has `Read` and `Show` instances, we can
write a pipe:

```haskell
-- f.hs
main = interact (show . f . read)
```

And use it thus:

    pandoc -t native -s | runghc f.hs | pandoc -f native -s -t latex

# JSON filters

`Read` and `Show` are really slow.  Better to use JSON serialization:

    pandoc -t json -s | runghc fjson.hs | pandoc -f json -s -t latex

. . .

To simplify this pattern, we added `--filter`:

    pandoc -s -t latex --filter fjson.hs

# toJSONFilter

[Text.Pandoc.JSON](doc/pandoc-types/Text-Pandoc-JSON.html)

`toJSONFilter` takes any function `a -> a` or `a -> [a]` or
`a -> IO a`, where `a` is a Pandoc type, and turns it into a
JSON filter.

```haskell
import Text.Pandoc.JSON
import AllCaps (allCaps)

main = toJSONFilter allCaps
```

# Example: `emphToCaps.hs`

```haskell
-- pandoc --filter ./emphToCaps.hs
import Text.Pandoc.JSON
import Text.Pandoc.Walk
import AllCaps (allCaps)

emphToCaps :: Inline -> [Inline]
emphToCaps (Emph xs) = walk allCaps xs
emphToCaps x = [x]

main :: IO ()
main = toJSONFilter emphToCaps
```

# Output format conditionalization

`pandoc --filter` passes the name of the output format as
first argument to the filter.  So the filter's behavior
can depend on the output format.

`toJSONFilter` makes this easy:  just use a function whose
first argument is `Maybe Format`.

# Example:  `emphToCaps2.hs`

Emph as <span style="font-variant:small-caps;">Small Caps</span>
in LaTeX and HTML, ALL CAPS otherwise:

```haskell
-- pandoc --filter ./emphToCaps2.hs
import Text.Pandoc.JSON
import Text.Pandoc.Walk
import AllCaps (allCaps)

emphToCaps :: Maybe Format -> Inline -> [Inline]
emphToCaps (Just f) (Emph xs)
  | f == Format "html" || f == Format "latex" = [SmallCaps xs]
emphToCaps _ (Emph xs) = walk allCaps xs
emphToCaps _ x = [x]

main :: IO ()
main = toJSONFilter emphToCaps
```

# Exercises

<http://johnmacfarlane.net/BayHac2014-exercises.pdf>
